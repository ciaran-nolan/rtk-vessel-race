// Protocol to enable the pin to transmit its relative position to the base station
// At the moment this message is unacknowledged
// The relative position is 

#include <RHReliableDatagram.h>
#include <RH_RF95.h>
#include <SPI.h>

#define CLIENT_ADDRESS 2
#define BASE_ADDRESS 1

#define RFM95_CS 5
#define RFM95_RST 6
#define RFM95_INT 10
#define RF95_FREQ 434.0

const uint8_t external_interrupt = 13;

//Globals flags
int rtcm_flag = 0;
unsigned long flag_time;
int can_send_relposned = 0;


//// Data Buffers ///////////////////
uint8_t data[] = "I have finished!";
char relposned[46];
// array to hold pin position and timestamp
uint8_t pin_position[12];
// buffer  for received messages
uint8_t buf[RH_RF95_MAX_MESSAGE_LEN];
////////////////////////////////////
/////// END BUFFERS ///////////////


// Singleton instance of the radio driver
RH_RF95 driver(RFM95_CS, RFM95_INT);


// Class to manage message delivery and receipt, using the driver declared above
RHReliableDatagram pin(driver, CLIENT_ADDRESS);

void toggle(){
    rtcm_flag = 1;  
    flag_time = millis();
  }

void setup() 
{ 
  // set the pin mode of the external interrupt 
  pinMode(external_interrupt, INPUT);
  // set up interrupt for timepulse
  attachInterrupt(digitalPinToInterrupt(external_interrupt), toggle, RISING);
 
  //USB for debug
  Serial.begin(38400);
  // USART TX and RX pins.
  // TX for sending Received RTCM data to GPS
  // RX for receiving the UBX-NAV-RELPOSNED message describing the pins location
  Serial1.begin(115200);

  while (!Serial) ; // Wait for serial port to be available

  //Initialise manager class and hence the radio with default settings
 
  ////////////////// Defaults //////////////////
  /// Frequency 434MHz                       ///
  /// Tx Power: 13dBm                        ///
  /// Bandwidth: 125KHz                      ///
  /// Coding Rate: 4/5                       ///
  /// Spreading Factor: 128 chips/ Symbol    ///
  /// CRC On                                 ///
  //////////////////////////////////////////////

  // Note HOPERF RFM96 module uses a PA_BOOST transmitter pin 
  // Power Range: 5 to 23 dBm:
  // Example rover.setTxPower(23, false);
  
  if (!pin.init())
    Serial.println("init failed");
  else
    Serial.println("init succesful"); 
}


// send RTCM corrections to GNSS Unit 
void handle_message(uint8_t len){
  //only send rtcm to the GNSS
  if(buf[0] == 0xD3){
    Serial1.write(buf, len);
    Serial.write(buf, len);
  }
}

//retrive relevant info from UBX message
void compute_relposned(){
    // following the UBX protocol
    // UBX-NAV_RELPOSNED is 46 Bytes long, the pin is concerned with three elements of this message only:
    // The Northern Offset of the pin from the committee boat
    // The Eastern Offseet of the pin from the committee boat
    // The timestamp in ms, generated by the GNSS unit
    if(Serial.available()){
      Serial.readBytes(relposned, 46);
      memcpy(pin_position, relposned+8 ,12*sizeof(uint8_t));
    }
    
}
void loop() {
    // RTCM period has timed out, set flag to zero
    if(rtcm_flag == 1 && (millis() - flag_time > 350)){
      // Debug
      Serial.println("End RTCM");
      rtcm_flag = 0;
      // pin can now send its position 
      can_send_relposned = 1;  
    }
   if(rtcm_flag == 1){
        uint8_t len = sizeof(buf);
        uint8_t from; 
        if(pin.recvfrom(buf, &len))
          handle_message(len);          
      }
     else if(can_send_relposned == 1){
        compute_relposned();
        if(pin.sendto(pin_position, sizeof(pin_position), BASE_ADDRESS))
          Serial.println("Pin Position Transmitted.");
        //pin has attempted to send position, wait until next cycle
        can_send_relposned = 0;
        
      }
    
   
      
  
  

}
